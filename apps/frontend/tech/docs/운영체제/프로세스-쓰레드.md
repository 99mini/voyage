---
sidebar_position: 0
slug: process-vs-thread
title: '프로세스와 쓰레드'
authors: [99mini]
tags: [운영체제, 프로세스]
---

<!-- 프로세스 0 ~ 9 -->

프로세스와 쓰레드

<!-- truncate -->

### 프로세스와 쓰레드

| 항목      | 프로세스 (Process)                                 | 쓰레드 (Thread)                                     |
| --------- | -------------------------------------------------- | --------------------------------------------------- |
| 정의      | 실행 중인 프로그램의 인스턴스                      | 프로세스 내에서 실행되는 흐름의 단위                |
| 독립성    | 각각 독립적인 메모리 공간을 가짐                   | 같은 프로세스의 쓰레드는 메모리 자원을 공유         |
| 자원      | 코드, 데이터, 힙, 스택을 독립적으로 소유           | 코드, 데이터, 힙은 공유하되, 스택은 개별적으로 가짐 |
| 생성 비용 | 상대적으로 비용이 큼 (메모리 할당, PCB 생성 등)    | 비용이 적고 빠르게 생성됨                           |
| 통신 방식 | 프로세스 간 통신(IPC: 파이프, 소켓 등) 필요        | 같은 메모리 공간을 공유하므로 간단                  |
| 안정성    | 하나의 프로세스가 죽어도 다른 프로세스에 영향 없음 | 하나의 쓰레드가 죽으면 전체 프로세스에 영향 가능    |
| 예시      | 브라우저, 텍스트 에디터                            | 탭마다 독립된 쓰레드, 워드에서 맞춤법 검사 쓰레드   |

### 구조

```text
[ 프로세스 구조 ]

+-----------------------------+
| 코드 (Code Segment)          |
+-----------------------------+
| 데이터 (Data)                 |
+-----------------------------+
| 힙 (Heap)                    |
+-----------------------------+
| 스택 (Stack)                 |
+-----------------------------+
| PCB (Process Control Block) |
+-----------------------------+


[ 쓰레드 구조 - 프로세스 내부 ]

+-----------------------------+
| 코드 (공유)                   |
+-----------------------------+
| 데이터 (공유)                  |
+-----------------------------+
| 힙 (공유)                     |
+-----------------------------+
| 스택 (개별)                   |
+-----------------------------+
| TCB (Thread Control Block)  |
+-----------------------------+
```

| 항목           | 프로세스             | 쓰레드                          |
| -------------- | -------------------- | ------------------------------- |
| 메모리 공간    | 독립적               | 공유                            |
| 생성/관리 비용 | 높음                 | 낮음                            |
| 통신 방식      | IPC 필요             | 공유 메모리를 통한 간단한 통신  |
| 장애 영향      | 독립적 (안정성 높음) | 하나의 쓰레드 장애 시 전체 영향 |

### 데이터 공유

#### 프로세스 간 메모리 공유 (Inter-Process Communication, IPC)

> 기본 원칙: 프로세스는 서로 독립된 메모리 공간을 가지므로, 기본적으로는 직접 메모리를 공유할 수 없습니다. 이를 위해 운영체제가 제공하는 IPC 메커니즘을 사용합니다

**대표적인 IPC 방법**

| 방법                        | 설명                                                        | 특징                      |
| --------------------------- | ----------------------------------------------------------- | ------------------------- |
| 공유 메모리 (Shared Memory) | 메모리의 일부를 여러 프로세스가 함께 접근할 수 있도록 설정  | 가장 빠름, 동기화 필요    |
| 메시지 큐 (Message Queue)   | 운영체제 커널이 관리하는 큐를 통해 메시지를 주고받음        | 구조적이고 안정적         |
| 파이프 (Pipe)               | 한 프로세스의 출력이 다른 프로세스의 입력이 되도록 연결     | 부모-자식 간 자주 사용    |
| 소켓 (Socket)               | 네트워크를 통해 통신 (같은 머신에서도 사용 가능)            | 유연성 높고 네트워크 사용 |
| 메모리 맵 파일 (mmap)       | 파일 내용을 여러 프로세스에서 공유하는 메모리 영역으로 매핑 | 공유 메모리와 유사        |

#### 쓰레드 간 메모리 공유

> 기본 원칙: 쓰레드는 동일한 프로세스 내에서 실행되기 때문에 기본적으로 코드, 데이터, 힙 영역은 공유합니다. 단, 스택은 각각 따로 가짐.

**공유 가능한 메모리 영역**

| 메모리 영역 | 공유 여부 | 예시                            |
| ----------- | --------- | ------------------------------- |
| 코드 영역   | ✅ 공유   | 함수, 명령어 등                 |
| 데이터 영역 | ✅ 공유   | 전역 변수, static 변수          |
| 힙 영역     | ✅ 공유   | 동적으로 할당된 메모리 (malloc) |
| 스택 영역   | ❌ 비공유 | 지역 변수, 함수 호출 스택       |

### 경쟁 조건(Race Condition)

둘 이상의 쓰레드가 동시에 공유 자원에 접근할 때, 접근 순서에 따라 결과가 달라지는 문제. 임계 구역(Critical Section) 보호를 통해서 해결할 수 있다.

임계 구역 해결 방법

| 방법                | 설명                                                   |
| ------------------- | ------------------------------------------------------ |
| 뮤텍스(Mutex)       | 한 번에 하나의 쓰레드만 접근 가능                      |
| 세마포어(Semaphore) | 카운터 기반의 접근 제어 (일반적으로 동시 접근 수 제한) |
| 모니터(Monitor)     | 객체 수준에서 임계 구역 보호 (Java의 synchronized)     |
| 락(Lock)            | 명시적 락 제어 (std::mutex, ReentrantLock 등)          |
| 조건 변수(CondVar)  | 특정 조건이 만족될 때만 접근 허용                      |

### 데드락(Deadlock)

두 개 이상의 쓰레드가 서로 자원을 점유한 상태에서 서로의 자원 해제를 기다리며 무한정 대기하는 상황.

#### Deadlock Conditions (Coffman Conditions)

1. 상호 배제(Mutual Exclusion): 자원은 동시에 하나의 쓰레드만 사용할 수 있음
2. 점유 대기(Hold and Wait): 자원을 점유한 상태에서 다른 자원을 기다림
3. 비선점(No Preemption): 자원을 강제로 회수할 수 없음
4. 순환 대기(Circular Wait): 서로가 가진 자원을 요구하는 순환 구조

:::tip

4가지 조건이 모두 충족될 때만 데드락이 발생. 하나라도 깨면 데드락 회피 가능

:::

#### 데드락 회피 방법

1. 자원 할당 그래프(Resource Allocation Graph)

- 노드: 프로세스 & 자원
- 간선: 할당/요구 관계
- 사이클 발생 여부로 데드락 탐지 가능

2. 데드락 컨디션 제거

| 조건 제거      | 방법                              |
| -------------- | --------------------------------- |
| 점유 대기 제거 | 자원 요청 전에 모두 할당받도록 함 |
| 순환 대기 제거 | 자원 번호를 부여해 순서대로 요청  |
| 비선점 제거    | 대기 중인 자원 강제로 회수        |

3. 알고리즘 기반

**은행원 알고리즘**(다익스트라)

- 요청된 자원을 할당했을 때 **시스템이 안전 상태(Safe State)**로 유지되는지 확인
- 안전 상태: 모든 프로세스가 순서대로 자원을 할당받아 완료 가능
- 자원 할당 → 시뮬레이션 → 안전 상태면 승인, 아니면 거절

```bash
pseudo code

if (request ≤ available && system remains safe)
    grant request
else
    deny request

```

### 문맥 교환 (Context Switching)

Context Switching이란, 운영체제가 CPU에서 현재 실행 중인 프로세스(또는 스레드)의 상태(Context)를 저장하고, 다른 프로세스의 상태를 불러와 실행을 전환하는 과정.

운영체제는 하나의 CPU를 여러 프로세스가 마치 동시에 사용하는 것처럼 보여주기 위해 빠르게 이 전환을 반복합니다. 이 과정을 CPU 스케줄링의 일부라고 볼 수 있다.

#### 문맥 교환이 일어나는 경우

- 타임 슬라이스 만료: Round Robin 등의 선점형 스케줄러에서 일정 시간 사용 후 전환
- I/O 요청: CPU를 쓰지 않고 입출력 기다림 → 다른 프로세스에게 CPU 양도
- 프로세스 종료: 다른 프로세스로 전환
- 높은 우선순위 프로세스 등장: 선점 스케줄러에서 즉시 CPU 점유권 전환
- 시스템 콜 수행: 커널 모드로 전환되면서 문맥 교환 발생 가능

#### 문맥 교환의 단계

1. 현재 실행 중인 프로세스의 상태(context)를 PCB(Process Control Block)에 저장
2. 스케줄러가 다음 실행할 프로세스 선택
3. 선택된 프로세스의 PCB에서 context를 복원
4. CPU는 새로운 프로세스의 실행을 이어감

#### 주요 스케줄링 알고리즘

1. FCFS (First-Come, First-Served)

- 비선점(Non-preemptive) 방식
- 문맥 교환 빈도 낮음 (완료 후에만 전환)
- Overhead 낮음, 응답 시간은 비효율적일 수 있음

2. SJF(Shortest Job First)

- 비선점 또는 선점형(Priority + Preemption) 가능
- 평균 대기 시간 최소화
- 선점형일 경우 문맥 교환 발생 가능성 ↑

3. SRT(Short Remaing Time)

- 선점형(Priority + Preemption) 가능
- 남은 실행 시간이 가장 짧은 프로세스를 선점
- 평균 대기 시간 최소화
- 문맥 교환 발생으로 인한 오버헤드 ↑

4. Round Robin (RR)

- 선점형(Preemptive) 알고리즘의 대표
- 타임 슬라이스(quantum)마다 강제 문맥 교환
- 문맥 교환 횟수 많음 → 오버헤드 증가

5. Priority Scheduling

- 선점형 가능
- 더 높은 우선순위 프로세스 등장 시 즉시 전환 → 문맥 교환 발생
- 우선순위 역전(Priority Inversion) 문제 발생 가능

6. Multilevel Queue / Feedback Queue

- 여러 큐 레벨에 따라 다른 정책 적용
- 문맥 교환이 빈번히 발생하며, CPU 사용 패턴에 따라 큐 이동 시 전환

:::tip

선점형 알고리즘일수록 문맥 교환이 자주 발생하며, 이는 시스템 응답성 향상과 오버헤드 증가 사이의 트레이드오프가 존재

:::
