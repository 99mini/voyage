---
sidebar_position: 10
slug: heap-n-stack
title: '힙과 스택'
authors: [99mini]
tags: [운영체제, 메모리]
---

<!-- 메모리 10 ~ 19 -->

힙과 스택

<!-- truncate -->

## 스택

- **컴파일 타임**에 크기가 고정된 데이터가 저장됩니다.
- **빠른 접근 속도**: 스택에 저장되는 데이터는 주소를 통해 접근하는 것이 아니라, 컴파일러가 오프셋으로 바로 접근하므로 매우 빠름(메모리 연속성)
- **자동 관리**: 함수 호출 시 스택 프레임이 쌓이고(push), 함수 종료 시 자동으로 정리(pop)
- **메모리 크기 제한**: 스택은 메모리 공간이 한정적이기 때문에 초과하면 프로그램이 비정상 종료됩니다. (Stack Overflow)
- **스택은 스레드마다 독립적으로 할당됨**: 멀티스레드 환경에서 중요

| 저장되는 항목                       | 설명                                    |
| ----------------------------------- | --------------------------------------- |
| 지역 변수 (Local Variables)         | 함수 내부에서 선언된 변수               |
| 함수 매개변수 (Function Parameters) | 함수 호출 시 전달된 인자값              |
| 반환 주소 (Return Address)          | 함수가 끝난 후 되돌아갈 주소            |
| 함수 호출 프레임(Call Stack Frame)  | 각 함수 호출마다 생성되는 실행 컨텍스트 |

### 스택오버플로우

- **함수 호출 스택(Stack Frame)** 이 과도하게 쌓이면 발생합니다.
- 스택은 메모리 공간이 **한정적**이기 때문에 초과하면 프로그램이 비정상 종료됩니다.

| 원인                       | 설명                         |
| -------------------------- | ---------------------------- |
| 무한 재귀 호출             | 탈출 조건 없는 재귀 함수     |
| 너무 깊은 재귀 호출        | 재귀 깊이가 스택 한계를 초과 |
| 지나치게 큰 지역 변수 선언 | 스택 메모리를 과도하게 사용  |

## 힙

- 메모리 할당과 해제가 **개발자/언어 런타임이 관리**합니다.
- 크기와 생명 주기가 고정되어 있지 않습니다.
- **유연한 크기**: 필요에 따라 동적으로 할당
- **느린 접근**: 포인터를 따라가야 함
- **명시적 관리 필요**: GC: Garbage Collection 필요
- **메모리 단편화(Fragmentation)**: 여러 번 할당/해제 시 빈 공간이 조각 조각으로 남음
- **공유 메모리**: 여러 프로세스나 쓰레드가 공유할 수 있음

| 저장되는 항목               | 설명                                                   |
| --------------------------- | ------------------------------------------------------ |
| 동적 객체 (Dynamic Objects) | new, malloc 등으로 생성된 객체                         |
| 동적 배열                   | 크기가 런타임에 결정되는 배열                          |
| 클로저 함수의 캡처된 변수   | (JavaScript, Python 등에서) 함수 바깥 변수를 참조할 때 |

### 힙 메모리 누수

- 프로그램이 실행되는 동안 **사용하지 않는 객체**가 힙에 계속 남아있으면 발생합니다.
- 힙은 자동 관리(가비지 컬렉션)가 있지만, 참조가 남아있으면 수거되지 않습니다.

| 원인                             | 설명                                       |
| -------------------------------- | ------------------------------------------ |
| 불필요한 참조 유지               | 필요 없는 객체를 변수/클로저가 계속 참조   |
| 전역 변수 사용                   | 프로그램 전체에서 해제되지 않음            |
| 이벤트 리스너 해제 누락          | DOM 요소가 삭제되어도 이벤트 리스너가 남음 |
| 타이머(setInterval 등) 해제 누락 | 타이머가 계속 실행되면서 참조 유지         |

- 필요 없는 참조를 **명시적으로 null 할당**하여 끊기
- DOM 요소를 삭제할 때 **이벤트 리스너도 같이 제거**
- `setInterval`, `setTimeout`은 **clearInterval**, **clearTimeout**으로 해제
- 전역 변수 사용 최소화

### 멀티쓰레딩 환경에서의 주의사항

스택은 스레드마다 독립이고, 힙은 공유 자원이다.

힙은 여러 스레드가 공유하므로 **경합(race condition)** 이나 동기화 필요성이 발생합니다. 이로 인해 `mutex`, `semaphore`와 같은 동기화 기법이 필수입니다.
