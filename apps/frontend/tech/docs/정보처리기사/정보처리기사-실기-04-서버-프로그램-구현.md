---
sidebar_position: 14
slug: 정보처리기사-실기-4장-서버-프로그램-구현
title: '[실기] 4장 서버 프로그램 구현'
authors: [99mini]
tags: [정보처리기사, 소프트웨어공학]
date: 2025-07-11
---

실기 4장 서버 프로그램 구현: 정보처리기사 실기 정리

<!-- truncate -->

## 서버 프로그램 구현

### 모듈화

- 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능을 모듈 단위로 나누는 것

### 추상화

- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것

### 정보은닉

- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.
- 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.

### 소프트웨어 아키텍처의 품질 속성

- 시스템측면 성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등
- 비즈니스 측면 시장 적시성, 비용과 혜택, 예상시스템 수명, 목표 시장, 공개 일정 등
- 아키텍처 측면 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등

### 아키텍처 패턴

#### 레이어드

- 시스템을 계층으로 구분하여 구성
- 서로 마주보는 두 개의 계층 사이에서만 상호작용
- 고전적인 방법

#### 클라이언트-서버

- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
- 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 서버에 요청을 전달하고 서버는 클라이언트의 요청을 처리하여 응답을 전달

#### 파이프 필터

- 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송되는 패턴
- 데이터변환, 버퍼링, 동기화 등에 주요 사용
- ex: unix shell pipe

#### 모델-뷰-컨트롤러(MVC)

- model, view, controller로 구조화
- model: 데이터를 저장하고 데이터의 변경을 관리
- view: 사용자 입력을 받아 controller에 전달하고 model의 결과를 사용자에게 전달
- controller: 사용자 입력을 받아 model에 전달하고 model의 결과를 view에 전달
- 사용자 -> view -> controller -> model -> view

#### 마스터-슬레이브(Master-Slave)

- 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업 수행
- ex: 장애 허용 시스템, 병렬 컴퓨팅 시스템

#### 브로커(Broker)

- 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 따라 적절한 컴포넌트와 사용자를 연결
- ex: 분산 환경 시스템

#### Peer-to-Peer(P2P)

- Peer라 부르는 컴포넌트가 서로 직접적으로 연결되어 데이터를 주고받는 방식
- Peer 컴포넌트는 클라이언트가 될 수도 있고 서버가 될 수도 있다
- ex: 파일 공유 시스템

#### 이벤트 버스(Event Bus)

- 소스가 특정 채널에 이벤트 메시지를 발행(publish)
- 해당 채널을 구독(subscribe)한 소스가 이벤트 메시지를 수신하여 처리
- ex: 알림 서비스, mosquitto

#### 블랙보드 (Blackboard)

- 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능
- ex: 음성인식, 차량 식별, 신호 해석

#### 인터프리터 (Interpreter)

- 코드의 각 라인을 수행하는 방법을 지정
- 기호마다 클래스를 갖도록 구성
- ex: 번역기, 컴파일러

### 객체지향

#### 연관성

| 종류           | 의미                          | 특징                                           |
| -------------- | ----------------------------- | ---------------------------------------------- |
| is member of   | 연관화(Association)           | 2개 이상의 객체가 상호관련되어 있음            |
| is instance of | 분류화(Classification)        | 동일한 형의 특성을 갖는 객체들을 모아 구성     |
| is part of     | 집단화(Aggregation)           | 관련있는 객체들을 묶어 하나의 상위 객체를 구성 |
| is a           | 일반화(Generalization)        | 공통적인 성질들로 추상화한 상위 객체를 구성    |
| is a           | 특수화/상세화(Specialization) | 상위 객체를 구체화하여 하위 객체를 구성        |

### 객체지향 분석

#### Rumbaugh(럼바우)

- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링
- 객체(Object) 모델링: 객체들 간의 관계를 규정하여 객체 다이어그램으로 표현
- 동적(Dynamic) 모델링: 상태 다이어그램을 이용하여 제어흐름, 상호작용, 동작 순서 등의 동적인 행위를 표현
- 기능(Function) 모델링: 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정 표현
- 객체 모델링 -> 동적 모델링 -> 기능 모델링

#### Booch(부치)

- 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용
- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의

#### Jacobson

- 유스케이스를 강조하여 시스템의 요구사항을 정의

#### Coad and Yourdon

- E-R 다이어그램을 사용하여 객체의 행위를 모델링
- 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의

#### Wirfs-Brock

- 분석과 설계 간의 구분 없이 고객 명세서를 평가하여 설계 작업까지 연속적으로 수행

### 객체지향 설계 원칙 (SOLID)

- 단일 책임 원칙 (Single Responsibility Principle): 하나의 모듈이 하나의 책임만 가지도록 설계
- 개방 폐쇄 원칙 (Open/Closed Principle): 기능을 추가하거나 수정할 때 기존 코드를 수정하지 않도록 설계
- 리스코프 치환 원칙 (Liskov Substitution Principle): 하위 타입은 상위 타입의 모든 성질을 가져야 함
- 인터페이스 분리 원칙 (Interface Segregation Principle): 사용하지 않는 인터페이스와 의존 관계를 가지지 않도록 설계
- 의존성 역전 원칙 (Dependency Inversion Principle): 구체적인 구현체에 의존하지 않고 추상화된 인터페이스에 의존하도록 설계

### 결합도와 응집도

결합도는 낮게 응집도는 높게 설계하는 것이 좋음

#### 결합도 (Coupling)

> 아래로 갈수록 결합도가 낮아짐. 품질이 좋아짐

1. 내용 결합도 (Content Coupling): 모듈이 다른 모듈의 내부 구조(내부 기능 및 내부 자료)에 의존
2. 공통(공유) 결합도 (Common Coupling): 공유되는 공통 데이터 영역(전역 변수 등)을 통해 다른 모듈과 의사소통
3. 외부 결합도 (External Coupling): 어떤 모듈에서 선언한 데이터(변수)를 다른 모듈에서 참조
4. 제어 결합도 (Control Coupling): 어떤 모듈이 다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달
5. 스탬프 결합도 (Stamp Coupling): 모듈 간의 인터페이스로 배열이나 레코드 등의 자료구조가 전달
6. 자료 결합도 (Data Coupling): 모듈 간의 인터페이스가 자료 요소로만 구성

#### 응집도 (Cohesion)

> 아래로 갈수록 응집도가 낮아짐. 품질이 떨어짐

1. 기능성 응집도 (Functional Cohesion): 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행
2. 순차적 응집도 (Sequential Cohesion): 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력데이터로 사용
3. 교환(통신)적 응집도 (Communicational Cohesion): 동일한 입출력을 사용하여 서로 다른 기능을 수행
4. 절차적 응집도 (Procedural Cohesion): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행
5. 시간적 응집도 (Temporal Cohesion): 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성
6. 논리적 응집도 (Logical Cohesion): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈을 형성
7. 우연적 응집도 (Coincidental Cohesion): 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성

### 팬인/팬아웃

- 팬인: 제어하는 모듈의 수
- 팬아웃: 제어당하는 모듈의 수

### IPC(Inter-Process Communication)

- 모듈간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스
- 예시
  - 공유메모리
  - 소켓
  - 세마포어
  - 파이프와 네임드 파이프
  - 메시지 큐잉

### 공통 모듈 명세 기법

- **정확성(Correctness)**: 시스템 구현시 해당 기능의 필요성을 정확히 작성
- **명확성(Clarity)**: 해당 기능을 명확하게 작성
- **완전성(Completeness)**: 시스템 구현을 위해 필요한 모든 것을 기술
- **일관성(Consistency)**: 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
- **추적성(Traceability)**: 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

### 디자인 패턴

GoF 디자인 패턴: 생성패턴, 구조패턴, 행위패턴으로 구분

#### 생성패턴(Creational Pattern)

- **싱글톤(Singleton)**: 하나의 객체를 생성하면 생성된 객체를 어디서는 참조할 수 있지만 여러 프로세스가 동시에 참조할 수 없는 패턴. 클래스 내에서 인스턴스가 하나뿐임을 보장
- **팩토리 메소드(Factory Method)**: 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화. 상위 클래스에서 인터페이스만 정의하고, 구현은 서브 클래스에서 처리
- **추상팩토리(Abstract Factory)**: 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관-의존하는 객체들의 그룹으로 생성하여 추상화
- **빌더(Builder)**: 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성. 생성 과정과 표현 방법 분리. 동일한 객체 생성에서도 서로 다른 결과를 만들 수 있다.
- **프로토타입(Prototype)**: 원복 객체를 복제하는 방법으로 객체 생성

:::tip[Factory Method vs Abstract Factory]

팩토리 메소드 패턴: ConcreteProduct를 생성. 인자에 따라 객체의 종류 결정
추상팩토리 패턴: ConcreteFactory를 생성. 인자에 따라 관련 객체를 생성하는 **팩토리**의 종류 결정

:::

#### 구조패턴(Structural Pattern)

- **어댑터(Adaptor)**: 호환성 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환.
- **브리지(Bridge)**: 구현부와 추상부를 분리하여 독립적으로 변경 가능. 서로 독립적으로 확장 가능
- **컴포지트(Composite)**: 복합 객체를 단순 객체와 동일하게 처리하여 구조를 단순화. 객체들을 트리 구조로 구성하여 복합 객체 안에 복합 객체가 포함되는 구조를 구현
- **데코레이터(Decorator)**: 객체에 책임을 동적으로 추가하여 기능을 확장. 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식
- **프록시(Proxy)**: 접근이 어려운 객체와 연결하려는 객체 사이에 인터페이스 역할을 수행. 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용
- **퍼싸드(Facade)**: 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴. 서브 클래스들 사이의 통합 인터페이스르 제공하기 위해 Wrapper 객체 필요.
- **플라이웨이트(Flyweight)**: 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴

#### 행위패턴(Behavioral Pattern)

- **커맨드(Command)**: 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남김
- **책임연쇄(Chain of Responsibility)**: 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태
- **인터프리터(Interpreter)**: 언어에 문법 표현을 정의하는 패턴. SQL이나 통신 프로토콜 등 개발에 이용
- **반복자(Iterator)**: 자료구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴. 내부 표현의 방법과 노출없이 순차적인 접근이 가능
- **중재자(Mediator)**: 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의. 객체들 사이의 의존성을 줄여 결합도를 감소
- **메멘토(Memento)**: 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공
- **옵저버(Observer)**: 한 객체의 상태가 변화하면 객체에 상속되어있는 다른 객체들에게 변화된 상태를 전달. 분산된 시스템 간에 이벤트를 생성(publish)하고 구독(subscribe)하는 방식으로 구현
- **상태(State)**: 객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용. 상태를 캡슐화하고 참조하는 방식으로 처리
- **전략(Strategy)**: 동일한 계열의 알고리즘을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의. 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용. 클라이언트의 영향없이 알고리즘 교체 가능
- **템플릿메소드(Template Method)**: 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화. 유사한 서브클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 유지보수 용이
- **방문자(Visitor)**: 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성. 분리된 처리 기능을 각 클래스를 방문하며 수행

### 배치 프로그램

- 사용자의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램
