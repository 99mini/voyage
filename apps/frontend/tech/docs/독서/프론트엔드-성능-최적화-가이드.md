---
sidebar_position: 1
slug: 프론트엔드-성능-최적화-가이드
title: '[FE] 프론트엔드 성능 최적화 가이드'
authors: [99mini]
tags: [프론트엔드, react]
date: 2025-07-27
---

<!-- truncate -->

> 작성일: 2025-07-27

도서: [프론트엔드 성능 최적화 가이드](https://product.kyobobook.co.kr/detail/S000200178292)

### 후기

프론트엔드 개발을 하면서 성능 문제를 마주하게 되었을 때, 적용할 수 있는 실무적인 해결방안을 제시해줍니다. 4가지 예시를 통해서 흔히 발생할 수 있는 상황별 성능 최적화 방법을 설명합니다.

### 텍스트 압축

HTTP 서버 요청에서 Response Header에 Content-Encoding을 gzip으로 설정하여 텍스트 데이터를 압축하여 전달합니다.

### 애니메이션 최적화

```txt title="브라우저의 렌더링 과정"
DOM + CSSOM -> Render Tree -> Layout -> Paint -> Composite
```

:::tip 리플로우와 리페인트를 발생시키는 속성

리플로우: position, display, width, height, font-family, font-size, font-weight, top, left, line-height, min-height, margin, padding, border 등
리페인트: backgtround, background-image, background-position, border-radius, border-style, box-shadow, color, line-style, outline 등

:::

#### 리플로우와 리페인트 피하기 (GPU 가속)

transform과 opacity 속성을 이용하여 하드웨어 가속을 통해 그래픽 작업 처리를 효율적으로 처리할 수 있다.

### 컴퓨넌트 지연 로딩과 사전 로딩

React의 `lazy`와 `Suspense`를 사용하여 컴퓨넌트 지연 로딩과 사전 로딩을 구현할 수 있다.

#### 사전 로딩

1. `useEffect`이용

컴포넌트가 모두 렌더링 후 지연 로딩할 컴포넌트를 import하는 방법

```javascript
const App = () => {
  useEffect(() => {
    const lazyComponent = import('./LazyComponent');
  }, []);

  return <div>{/* lazyComponent가 로딩되면 컴포넌트를 렌더링 */}</div>;
};
```

2. `mouseenter`이벤트 이용

```javascript
const App = () => {
  const handleMouseEnter = () => {
    const lazyComponent = import('./LazyComponent');
  };

  return (
    <div>
      <button onMouseEnter={handleMouseEnter}>지연로딩 컴포넌트</button>
    </div>
  );
};
```

### 미디어(이미지, 비디오) 최적화

**이미지 포멧**

| 포멧 | 사이즈 | 화질 | 호환성               |
| ---- | ------ | ---- | -------------------- |
| webp | 작음   | 높음 | 일부 브라우저 미지원 |
| jpg  | 중간   | 중간 | ✅                   |
| png  | 큼     | 높음 | ✅                   |

```html title="이미지 포멧에 따라 분류"
<picture>
  <source srcset="image.webp" type="image/webp" />
  <source srcset="image.jpg" type="image/jpeg" />
  <img src="image.jpg" alt="image" />
</picture>
```

```html title="비디오 포멧에 따라 분류"
<video>
  <source src="video.mp4" type="video/mp4" />
  <source src="video.webm" type="video/webm" />
  <source src="video.ogv" type="video/ogg" />
</video>
```

#### 리엑트에서 이미지 최적화 (Observer API)

```javascript title="image-observer.js"
import { useEffect, useState } from 'react';

const ImageObserver = ({ src, webpSrc }) => {
  const imgEl = useRef(null);

  useEffect(() => {
    const options = {};

    const callback = (entries, observer) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const sourceEl = entry.target.previousElementSibling;
          sourceEl.srcset = sourceEl.dataset.srcset;
          entry.target.src = entry.target.dataset.src;
          observer.unobserve(entry.target);
        }
      });
    };

    const observer = new IntersectionObserver(callback, options);
    observer.observe(imgEl.current);
  }, [src]);

  return (
    <picture>
      {/* data-srcset과 data-src를 사용하여 이미지가 의도된 타이밍에 useEffect의 callback 함수에서 srcset과 src를 설정합니다. */}
      <source data-srcset={webpSrc} type="image/webp" />
      <img data-src={src} alt="image" ref={imgEl} />
    </picture>
  );
};
```

### 불필요한 CSS 제거

css파일에서 선언하였지만 사용하지 않는 선택자 혹은 tailwindcss의 css파일에서 불필요한 css를 제거하여 빌드 파일 사이즈를 줄입니다.

purge 옵션을 사용하여 불필요한 CSS를 제거할 수 있습니다.

### 레이아웃 이동 피하기 (Cumulative Layout Shift)

1. 사이즈가 정의되지 않은 이미지 요소
2. 사이즈가 정의되지 않은 광고 요소
3. 동적으로 삽입된 컨텐츠
4. 웹 폰트(FOIT, FOUT)

```css
.wrapper {
  position: relative;
  width: 160px;         // 이미지 너비 고정
  padding-top: 56.25%;  // 이미지 비율 고정 (16:9)
  /* aspect-ratio: 16 / 9; // 비율 속성 사용 가능 */
}

.image {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
```

### 리덕스 렌더링 최적화

리덕스 등 리액트 훅 기반 상태 관리 라이브러리는 상태가 변경되면 컴포넌트가 리렌더링됩니다. 이때 상태를 구독하는 컴포넌트가 많아지거나 구독 상태의 요소가 참조(배열, 객체)로 이루어진 경우 의도하지 않은 리렌더링이 발생할 수 있습니다.

이를 해결하기 위해선 상태를 구독하는 컴포넌트가 필요로 하는 상태만을 구독하는 것이 좋습니다. 혹은 상태를 비교하는 함수를 사용하여 상태가 변경되었을 때만 리렌더링을 수행할 수 있습니다.

---

필요한 상태만 구독하는 방법으로는 객체나 배열로 이루어진 상태를 분할하여 자바스크립트의 원시 값으로 이루어진 상태를 구독하는 것입니다.

```javascript title="참조 상태를 원시값으로 분할(AS-IS)"
const { modalVisible, bgColor, src, alt } = useSelector((state) => ({
  modalVisible: state.modal.modalVisible,
  bgColor: state.modal.bgColor,
  src: state.modal.src,
  alt: state.modal.alt,
}));

const category = useSelector((state) => ({ category: state.category.category })); // { category: 'all' } 형태
```

```javascript title="참조 상태를 원시값으로 분할(To-BE)"
const modalVisible = useSelector((state) => state.modal.modalVisible);
const bgColor = useSelector((state) => state.modal.bgColor);
const src = useSelector((state) => state.modal.src);
const alt = useSelector((state) => state.modal.alt);
const category = useSelector((state) => state.category.category); // 객체 형태를 destructuring해서 사용
```

---

상태 비교 함수를 사용하는 방법은 리덕스의 경우 `shallowEqual`을 사용할 수 있습니다.

```javascript title="상태 비교 함수 사용(AS-IS)"
const { photos, loading } = useSelector((state) => ({
  photos:
    state.category.category === 'all'
      ? state.category.photos
      : state.category.photos.filter((photo) => photo.category === state.category.category),
  loading: state.category.loading,
}));
```

```javascript title="상태 비교 함수 사용(To-BE)"
const { photos, loading } = useSelector(
  (state) => ({
    photos:
      state.category.category === 'all'
        ? state.category.photos
        : state.category.photos.filter((photo) => photo.category === state.category.category),
    loading: state.category.loading,
  }),
  shallowEqual, // 상태 비교 함수
);
```
