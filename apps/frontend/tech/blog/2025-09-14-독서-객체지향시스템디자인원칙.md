---
slug: 객체지향-시스템-디자인-원칙
title: 객체지향 시스템 디자인 원칙 (Simple Object Oriented Design)
date: 2025-09-14
authors: [99mini]
tags: [독서, 객체지향]
---

[독서] 객체지향 시스템 디자인 원칙 (Simple Object Oriented Design) - 마우리시오 아니체 지음

[교보문고](https://product.kyobobook.co.kr/detail/S000216884277)

<!-- truncate -->

## 서문

프론트엔드 개발자로 공부를 하면서 객체지향 프로그래밍을 적용하여 유자보수와 확장성을 높이는 방법을 고민하게 되었다.
이 책은 백엔드를 기반으로 하여 (예제 코드가 Java 기반의 pseudo code로 작성되어 있음) 객체지향 시스템 디자인 원칙을 설명하고 있지만, 프론트엔드 개발자에게도 많은 도움이 될 것이라 생각되어 읽게 되었다.

## 책 소개

명확하고 간결한 객체지향 시스템 디자인 원칙을 제시하는 책이다. 6가지 원칙을 통해 유지보수성과 확장성을 높이는 방법을 예제와 함께 설명한다.

- 코드를 작게 유지하는 방법
- 객체의 일관성을 유지하는 방법
- 의존성을 적절하게 관리하는 방법
- 추상화를 이해하고 잘 디자인하는 방법
- 인프라를 올바르게 처리하고 다루는 방법
- 잘 모듈화된 디자인을 달성하는 방법

위 6가지 원칙의 세부내용 중 일부 원칙을 요약하며 프론트엔드 개발에 어떻게 적용할 수 있을지 고민해보았다.

## 1. 코드를 작게 유지하라

### 코드를 작은 단위로 나누지 말아야 할 때

> - 둘 이상의 퍼즐 조각이 독립적으로 존재할 수 없을 때. 강제로 분리하면 메서드 시그니처가 복잡해질 수 있다.
> - 퍼즐 코드 조각이 교체될 가능성이 낮을 때.
> - 해당 조각만 완전히 따로 떼어 테스트(단위 테스트)할 만한 가치가 없을 때.

코드를 작은 단위로 나누는 것은 유지보수성과 확장성을 높이는 데 도움이 되지만, 지나치게 작은 단위로 나누면 오히려 복잡성을 증가시킬 수 있다. 따라서 코드의 응집도를 고려하여 적절한 크기로 유지하는 것이 중요하다.

---

객체지향, 함수형 프로그래밍 등 다양한 패러다임을 실무에 적용하면서 처음부터 기능을 작은 단위로 나누거나 리펙토링 과정에서 기능을 작은 단위로 분리하는 경우가 많다.
그러나 작은 단위로 나누는 것이 항상 좋은 것은 아니다. 작은 단위로 나누면 코드의 응집도가 떨어지고, 오히려 복잡성이 증가할 수 있다.

```jsx title="react에서 작은 단위로 나누는 경우"
// 작은 단위로 나누는 경우
function UserProfile({ user }) {
  return (
    <div>
      <UserAvatar avatar={user.avatar} />
      <UserName name={user.name} />
      <UserBio bio={user.bio} />
    </div>
  );
}

function UserAvatar({ avatar }) {
  return <img src={avatar} alt="User Avatar" />;
}

function UserName({ name }) {
  return <h2>{name}</h2>;
}

function UserBio({ bio }) {
  return <p>{bio}</p>;
}
```

위 예제는 UserProfile 컴포넌트를 작은 단위로 나눈 경우이다. 각 컴포넌트가 독립적으로 존재할 수 없고, 교체될 가능성이 낮으며, 단위 테스트할 만한 가치가 없다. 따라서 UserProfile 컴포넌트를 하나의 컴포넌트로 유지하는 것이 더 나을 수 있다.

```jsx title="react에서 작은 단위로 나누지 않는 경우"
// 작은 단위로 나누지 않는 경우
function UserProfile({ user }) {
  return (
    <div>
      <img src={user.avatar} alt="User Avatar" />
      <h2>{user.name}</h2>
      <p>{user.bio}</p>
    </div>
  );
}
```

그렇다면 언제 작은 단위로 나누는 것이 좋을까?

- 둘 이상의 퍼즐 조각이 독립적으로 존재할 수 있을 때.
  - UserAvatar 컴포넌트가 다른 곳에서도 재사용될 수 있다면 작은 단위로 나누는 것이 좋다.
- 퍼즐 코드 조각이 교체될 가능성이 높을 때.
  - UserAvatar 컴포넌트가 다른 디자인으로 교체될 가능성이 있다면 작은 단위로 나누는 것이 좋다.
- 해당 조각만 완전히 따로 떼어 테스트(단위 테스트)할 만한 가치가 있을 때.
  - UserAvatar 컴포넌트가 복잡한 로직을 가지고 있고, 단위 테스트할 필요가 있다면 작은 단위로 나누는 것이 좋다.

```jsx title="react에서 작은 단위로 나누는 경우 (적절한 경우)"
// 작은 단위로 나누는 경우 (적절한 경우)
function UserProfile({ user }) {
  return (
    <div>
      <UserAvatar avatar={user.avatar} />
      <UserName name={user.name} />
      <UserBio bio={user.bio} />
      <UserFollowButton userId={user.id} />
    </div>
  );
}
function UserAvatar({ avatar }) {
  const avatarUrl = getAvatarUrl(avatar); // 복잡한 로직
  const handleAvatarClick = () => {
    // 단위 테스트할 필요가 있는 로직
    console.log('Avatar clicked');
  };

  return (
    <div>
      <img src={avatarUrl} alt="User Avatar" />
      <button onClick={handleAvatarClick}>Edit</button>
    </div>
  );
}
```

## 2. 객체의 일관성을 유지하라

### 항상 일관성을 유지하라

> - 클래스가 스스로 일관성을 책임지게 하라
> - 전체 작업과 복잡한 일관성 검사를 캡슐화하라

객체의 상태가 일관성을 유지하도록 하는 것은 매우 중요하다. 객체가 일관성을 유지하지 않으면, 예기치 않은 동작이 발생할 수 있다. 따라서 객체는 스스로 일관성을 책임지도록 설계해야 한다.

클리이언트는 절대 일관성 검사를 책임지지 말아야 하며, 기본적으로 클래스가 일관성을 관리해야 한다. 만약 클랙스에 들어가기에 검사가 너무 복잡하다면, 전체 작업을 서비스 클래스로 이동시키고 클라이언트가 원하는 동작을 위해 그 서비스 클래스를 사용해야 한다. [P.69]

---

```jsx title="잘못된 예시 - 클라이언트가 일관성 검사를 담당"
// ❌ 잘못된 예시 - 클라이언트가 일관성을 책임짐
function ShoppingCart() {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  const addItem = (item) => {
    // 클라이언트가 일관성 검사를 담당
    if (item.price <= 0) {
      throw new Error('가격은 0보다 커야 합니다');
    }
    if (!item.name || item.name.trim() === '') {
      throw new Error('상품명은 필수입니다');
    }

    setItems([...items, item]);
    // 클라이언트가 total 계산도 담당
    setTotal(total + item.price);
  };

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>
            {item.name} - {item.price}원
          </li>
        ))}
      </ul>
      <div>총 금액: {total}원</div>
    </div>
  );
}
```

```jsx title="올바른 예시 - 클래스가 일관성을 담당"
// ✅ 올바른 예시 - CartService가 일관성을 관리
class CartService {
  constructor() {
    this.items = [];
  }

  addItem(item) {
    // 클래스 내부에서 일관성 검사
    this._validateItem(item);
    this.items.push({ ...item });
  }

  removeItem(itemId) {
    this.items = this.items.filter((item) => item.id !== itemId);
  }

  getTotal() {
    // 클래스가 총합 계산을 책임짐
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }

  getItems() {
    return [...this.items]; // 불변성 유지
  }

  _validateItem(item) {
    if (!item || typeof item !== 'object') {
      throw new Error('유효하지 않은 상품입니다');
    }
    if (!item.name || item.name.trim() === '') {
      throw new Error('상품명은 필수입니다');
    }
    if (typeof item.price !== 'number' || item.price <= 0) {
      throw new Error('가격은 0보다 큰 숫자여야 합니다');
    }
    if (!item.id) {
      throw new Error('상품 ID는 필수입니다');
    }
  }
}

function ShoppingCart() {
  const cartServiceRef = useRef(new CartService());
  const cartService = cartServiceRef.current;

  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  const addItem = (item) => {
    try {
      cartService.addItem(item);
      // 클라이언트는 단순히 상태만 업데이트
      setItems(cartService.getItems());
      setTotal(cartService.getTotal());
    } catch (error) {
      alert(error.message);
    }
  };

  return (
    <div>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name} - {item.price}원
          </li>
        ))}
      </ul>
      <div>총 금액: {total}원</div>
    </div>
  );
}
```

```tsx title="올바른 예시 - 함수형 프로그래밍 스타일 일관성 담당"
// ✅ 올바른 예시 - 함수형 프로그래밍 스타일
function validateItem(item) {
  if (!item || typeof item !== 'object') {
    throw new Error('유효하지 않은 상품입니다');
  }
  if (!item.name || item.name.trim() === '') {
    throw new Error('상품명은 필수입니다');
  }
  if (typeof item.price !== 'number' || item.price <= 0) {
    throw new Error('가격은 0보다 큰 숫자여야 합니다');
  }
  if (!item.id) {
    throw new Error('상품 ID는 필수입니다');
  }
  return true;
}

function addItem(items, item) {
  validateItem(item);
  return [...items, { ...item }]; // 불변성 유지
}

function ShoppingCart() {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  const handleAddItem = (item) => {
    try {
      // addItem 함수는 일관성 검사를 포함하는 순수 함수
      // 복사본을 반환함으로써 불변성 유지
      const newItems = addItem(items, item);
      setItems(newItems);
      // 총합 계산도 함수로 분리
      const newTotal = newItems.reduce((sum, item) => sum + item.price, 0);
      setTotal(newTotal);
    } catch (error) {
      alert(error.message);
    }
  };

  return (
    <div>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name} - {item.price}원
          </li>
        ))}
      </ul>
      <div>총 금액: {total}원</div>
    </div>
  );
}
```

## 3. 의존성을 적절하게 관리하라

### 의존성을 주입하라 (의존성 주입을 사용하라)

> 의존성을 구성 요소에 주입하면 유연성과 테스트 가능성이 증가한다. 의존성을 주입할 수 있게 하면 구성 요소가 더 모듈화되고 독립적으로 쉽게 테스트할 수 있다. [P.111]

실행 시점에 클래스에 서로 다른 구체적인 구현을 전달할 수 있으면 디자인의 유연성이 높아진다. [P.111]

```tsx title="잘못된 예시 - 하드코딩된 의존성"
// ❌ 잘못된 예시 - 직접 의존성을 생성
class UserService {
  private httpClient: HttpClient;
  private logger: Logger;

  constructor() {
    // 하드코딩된 의존성 - 테스트하기 어렵고 유연성이 떨어짐
    this.httpClient = new HttpClient('https://api.example.com');
    this.logger = new ConsoleLogger();
  }

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id}`);
    return this.httpClient.get(`/users/${id}`);
  }
}

// React 컴포넌트에서 사용
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // 하드코딩된 서비스 인스턴스
    const userService = new UserService();
    userService.getUser(userId).then(setUser);
  }, [userId]);

  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

```tsx title="올바른 예시 - 의존성 주입 사용"
// ✅ 올바른 예시 - 인터페이스 정의
interface HttpClient {
  get<T>(url: string): Promise<T>;
  post<T, D = unknown>(url: string, data: D): Promise<T>;
}

interface Logger {
  log(message: string): void;
  error(message: string): void;
}

interface User {
  id: string;
  name: string;
  email: string;
}

// 구체적인 구현들
class FetchHttpClient implements HttpClient {
  constructor(private baseUrl: string) {}

  async get<T>(url: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${url}`);
    return response.json();
  }

  async post<T, D = unknown>(url: string, data: D): Promise<T> {
    const response = await fetch(`${this.baseUrl}${url}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return response.json();
  }
}

class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }

  error(message: string): void {
    console.error(`[ERROR] ${message}`);
  }
}

class SilentLogger implements Logger {
  log(message: string): void {}
  error(message: string): void {}
}

// 의존성 주입을 받는 서비스
class UserService {
  constructor(
    private httpClient: HttpClient,
    private logger: Logger,
  ) {}

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id}`);
    try {
      return await this.httpClient.get<User>(`/users/${id}`);
    } catch (error) {
      this.logger.error(`Failed to fetch user ${id}: ${error}`);
      throw error;
    }
  }

  async createUser(userData: Omit<User, 'id'>): Promise<User> {
    this.logger.log(`Creating user ${userData.name}`);
    return this.httpClient.post<User>('/users', userData);
  }
}

// React Context를 사용한 의존성 주입 컨테이너
interface ServiceContainer {
  userService: UserService;
  httpClient: HttpClient;
  logger: Logger;
}

const ServiceContext = React.createContext<ServiceContainer | null>(null);

// 의존성 주입 Provider
function ServiceProvider({ children }: { children: React.ReactNode }) {
  const services = useMemo(() => {
    const httpClient = new FetchHttpClient('https://api.example.com');
    const logger = process.env.NODE_ENV === 'production' ? new SilentLogger() : new ConsoleLogger();

    return {
      httpClient,
      logger,
      userService: new UserService(httpClient, logger),
    };
  }, []);

  return <ServiceContext.Provider value={services}>{children}</ServiceContext.Provider>;
}

// 서비스를 사용하는 커스텀 훅
function useServices(): ServiceContainer {
  const services = useContext(ServiceContext);
  if (!services) {
    throw new Error('useServices must be used within a ServiceProvider');
  }
  return services;
}

// React 컴포넌트에서 사용
function UserProfile({ userId }: { userId: string }) {
  const { userService } = useServices();
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    userService
      .getUser(userId)
      .then(setUser)
      .finally(() => setLoading(false));
  }, [userId, userService]);

  if (loading) return <div>Loading...</div>;
  return user ? (
    <div>
      {user.name} - {user.email}
    </div>
  ) : (
    <div>User not found</div>
  );
}

// 테스트용 Mock 구현
class MockHttpClient implements HttpClient {
  private mockData: Record<string, any> = {};

  setMockData(url: string, data: any) {
    this.mockData[url] = data;
  }

  async get<T>(url: string): Promise<T> {
    const data = this.mockData[url];
    if (!data) throw new Error(`No mock data for ${url}`);
    return Promise.resolve(data);
  }

  async post<T>(url: string, data: any): Promise<T> {
    return Promise.resolve(data as T);
  }
}

class TestLogger implements Logger {
  public logs: string[] = [];
  public errors: string[] = [];

  log(message: string): void {
    this.logs.push(message);
  }

  error(message: string): void {
    this.errors.push(message);
  }
}

// 테스트 예시
describe('UserService', () => {
  test('should fetch user successfully', async () => {
    const mockHttpClient = new MockHttpClient();
    const testLogger = new TestLogger();
    const userService = new UserService(mockHttpClient, testLogger);

    const mockUser: User = { id: '1', name: 'John Doe', email: 'john@example.com' };
    mockHttpClient.setMockData('/users/1', mockUser);

    const user = await userService.getUser('1');

    expect(user).toEqual(mockUser);
    expect(testLogger.logs).toContain('Fetching user 1');
  });
});
```

```tsx title="함수형 프로그래밍 스타일의 의존성 주입"
// ✅ 함수형 프로그래밍 스타일 의존성 주입
type HttpClient = {
  get: <T>(url: string) => Promise<T>;
  post: <T>(url: string, data: any) => Promise<T>;
};

type Logger = {
  log: (message: string) => void;
  error: (message: string) => void;
};

type Dependencies = {
  httpClient: HttpClient;
  logger: Logger;
};

// 의존성을 받는 함수들
const createUserOperations = (deps: Dependencies) => ({
  async getUser(id: string): Promise<User> {
    deps.logger.log(`Fetching user ${id}`);
    try {
      return await deps.httpClient.get<User>(`/users/${id}`);
    } catch (error) {
      deps.logger.error(`Failed to fetch user ${id}: ${error}`);
      throw error;
    }
  },

  async createUser(userData: Omit<User, 'id'>): Promise<User> {
    deps.logger.log(`Creating user ${userData.name}`);
    return deps.httpClient.post<User>('/users', userData);
  },
});

// React 컴포넌트에서 사용
function UserProfile({ userId }: { userId: string }) {
  const { httpClient, logger } = useServices();
  const userOps = useMemo(() => createUserOperations({ httpClient, logger }), [httpClient, logger]);

  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    userOps.getUser(userId).then(setUser);
  }, [userId, userOps]);

  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

---
