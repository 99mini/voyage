---
slug: 객체지향-시스템-디자인-원칙
title: 객체지향 시스템 디자인 원칙 (Simple Object Oriented Design)
date: 2025-09-14
authors: [99mini]
tags: [독서, 객체지향]
---

[독서] 객체지향 시스템 디자인 원칙 (Simple Object Oriented Design) - 마우리시오 아니체 지음

[교보문고](https://product.kyobobook.co.kr/detail/S000216884277)

<!-- truncate -->

## 서문

프론트엔드 개발자로 공부를 하면서 객체지향 프로그래밍을 적용하여 유자보수와 확장성을 높이는 방법을 고민하게 되었다.
이 책은 백엔드를 기반으로 하여 (예제 코드가 Java 기반의 pseudo code로 작성되어 있음) 객체지향 시스템 디자인 원칙을 설명하고 있지만, 프론트엔드 개발자에게도 많은 도움이 될 것이라 생각되어 읽게 되었다.

## 책 소개

명확하고 간결한 객체지향 시스템 디자인 원칙을 제시하는 책이다. 6가지 원칙을 통해 유지보수성과 확장성을 높이는 방법을 예제와 함께 설명한다.

- 코드를 작게 유지하는 방법
- 객체의 일관성을 유지하는 방법
- 의존성을 적절하게 관리하는 방법
- 추상화를 이해하고 잘 디자인하는 방법
- 인프라를 올바르게 처리하고 다루는 방법
- 잘 모듈화된 디자인을 달성하는 방법

위 6가지 원칙의 세부내용 중 일부 원칙을 요약하며 프론트엔드 개발에 어떻게 적용할 수 있을지 고민해보았다.

## 1. 코드를 작게 유지하라

### 코드를 작은 단위로 나누지 말아야 할 때

> - 둘 이상의 퍼즐 조각이 독립적으로 존재할 수 없을 때. 강제로 분리하면 메서드 시그니처가 복잡해질 수 있다.
> - 퍼즐 코드 조각이 교체될 가능성이 낮을 때.
> - 해당 조각만 완전히 따로 떼어 테스트(단위 테스트)할 만한 가치가 없을 때.

코드를 작은 단위로 나누는 것은 유지보수성과 확장성을 높이는 데 도움이 되지만, 지나치게 작은 단위로 나누면 오히려 복잡성을 증가시킬 수 있다. 따라서 코드의 응집도를 고려하여 적절한 크기로 유지하는 것이 중요하다.

---

객체지향, 함수형 프로그래밍 등 다양한 패러다임을 실무에 적용하면서 처음부터 기능을 작은 단위로 나누거나 리펙토링 과정에서 기능을 작은 단위로 분리하는 경우가 많다.
그러나 작은 단위로 나누는 것이 항상 좋은 것은 아니다. 작은 단위로 나누면 코드의 응집도가 떨어지고, 오히려 복잡성이 증가할 수 있다.

```jsx title="react에서 작은 단위로 나누는 경우"
// 작은 단위로 나누는 경우
function UserProfile({ user }) {
  return (
    <div>
      <UserAvatar avatar={user.avatar} />
      <UserName name={user.name} />
      <UserBio bio={user.bio} />
    </div>
  );
}

function UserAvatar({ avatar }) {
  return <img src={avatar} alt="User Avatar" />;
}

function UserName({ name }) {
  return <h2>{name}</h2>;
}

function UserBio({ bio }) {
  return <p>{bio}</p>;
}
```

위 예제는 UserProfile 컴포넌트를 작은 단위로 나눈 경우이다. 각 컴포넌트가 독립적으로 존재할 수 없고, 교체될 가능성이 낮으며, 단위 테스트할 만한 가치가 없다. 따라서 UserProfile 컴포넌트를 하나의 컴포넌트로 유지하는 것이 더 나을 수 있다.

```jsx title="react에서 작은 단위로 나누지 않는 경우"
// 작은 단위로 나누지 않는 경우
function UserProfile({ user }) {
  return (
    <div>
      <img src={user.avatar} alt="User Avatar" />
      <h2>{user.name}</h2>
      <p>{user.bio}</p>
    </div>
  );
}
```

그렇다면 언제 작은 단위로 나누는 것이 좋을까?

- 둘 이상의 퍼즐 조각이 독립적으로 존재할 수 있을 때.
  - UserAvatar 컴포넌트가 다른 곳에서도 재사용될 수 있다면 작은 단위로 나누는 것이 좋다.
- 퍼즐 코드 조각이 교체될 가능성이 높을 때.
  - UserAvatar 컴포넌트가 다른 디자인으로 교체될 가능성이 있다면 작은 단위로 나누는 것이 좋다.
- 해당 조각만 완전히 따로 떼어 테스트(단위 테스트)할 만한 가치가 있을 때.
  - UserAvatar 컴포넌트가 복잡한 로직을 가지고 있고, 단위 테스트할 필요가 있다면 작은 단위로 나누는 것이 좋다.

```jsx title="react에서 작은 단위로 나누는 경우 (적절한 경우)"
// 작은 단위로 나누는 경우 (적절한 경우)
function UserProfile({ user }) {
  return (
    <div>
      <UserAvatar avatar={user.avatar} />
      <UserName name={user.name} />
      <UserBio bio={user.bio} />
      <UserFollowButton userId={user.id} />
    </div>
  );
}
function UserAvatar({ avatar }) {
  const avatarUrl = getAvatarUrl(avatar); // 복잡한 로직
  const handleAvatarClick = () => {
    // 단위 테스트할 필요가 있는 로직
    console.log('Avatar clicked');
  };

  return (
    <div>
      <img src={avatarUrl} alt="User Avatar" />
      <button onClick={handleAvatarClick}>Edit</button>
    </div>
  );
}
```

## 2. 객체의 일관성을 유지하라

### 항상 일관성을 유지하라

> - 클래스가 스스로 일관성을 책임지게 하라
> - 전체 작업과 복잡한 일관성 검사를 캡슐화하라

객체의 상태가 일관성을 유지하도록 하는 것은 매우 중요하다. 객체가 일관성을 유지하지 않으면, 예기치 않은 동작이 발생할 수 있다. 따라서 객체는 스스로 일관성을 책임지도록 설계해야 한다.

클리이언트는 절대 일관성 검사를 책임지지 말아야 하며, 기본적으로 클래스가 일관성을 관리해야 한다. 만약 클랙스에 들어가기에 검사가 너무 복잡하다면, 전체 작업을 서비스 클래스로 이동시키고 클라이언트가 원하는 동작을 위해 그 서비스 클래스를 사용해야 한다. [P.69]

---

```jsx title="잘못된 예시 - 클라이언트가 일관성 검사를 담당"
// ❌ 잘못된 예시 - 클라이언트가 일관성을 책임짐
function ShoppingCart() {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  const addItem = (item) => {
    // 클라이언트가 일관성 검사를 담당
    if (item.price <= 0) {
      throw new Error('가격은 0보다 커야 합니다');
    }
    if (!item.name || item.name.trim() === '') {
      throw new Error('상품명은 필수입니다');
    }

    setItems([...items, item]);
    // 클라이언트가 total 계산도 담당
    setTotal(total + item.price);
  };

  return (
    <div>
      <ul>
        {items.map((item, index) => (
          <li key={index}>
            {item.name} - {item.price}원
          </li>
        ))}
      </ul>
      <div>총 금액: {total}원</div>
    </div>
  );
}
```

```jsx title="올바른 예시 - 클래스가 일관성을 담당"
// ✅ 올바른 예시 - CartService가 일관성을 관리
class CartService {
  constructor() {
    this.items = [];
  }

  addItem(item) {
    // 클래스 내부에서 일관성 검사
    this._validateItem(item);
    this.items.push({ ...item });
  }

  removeItem(itemId) {
    this.items = this.items.filter((item) => item.id !== itemId);
  }

  getTotal() {
    // 클래스가 총합 계산을 책임짐
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }

  getItems() {
    return [...this.items]; // 불변성 유지
  }

  _validateItem(item) {
    if (!item || typeof item !== 'object') {
      throw new Error('유효하지 않은 상품입니다');
    }
    if (!item.name || item.name.trim() === '') {
      throw new Error('상품명은 필수입니다');
    }
    if (typeof item.price !== 'number' || item.price <= 0) {
      throw new Error('가격은 0보다 큰 숫자여야 합니다');
    }
    if (!item.id) {
      throw new Error('상품 ID는 필수입니다');
    }
  }
}

function ShoppingCart() {
  const cartServiceRef = useRef(new CartService());
  const cartService = cartServiceRef.current;

  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  const addItem = (item) => {
    try {
      cartService.addItem(item);
      // 클라이언트는 단순히 상태만 업데이트
      setItems(cartService.getItems());
      setTotal(cartService.getTotal());
    } catch (error) {
      alert(error.message);
    }
  };

  return (
    <div>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name} - {item.price}원
          </li>
        ))}
      </ul>
      <div>총 금액: {total}원</div>
    </div>
  );
}
```

```tsx title="올바른 예시 - 함수형 프로그래밍 스타일 일관성 담당"
// ✅ 올바른 예시 - 함수형 프로그래밍 스타일
function validateItem(item) {
  if (!item || typeof item !== 'object') {
    throw new Error('유효하지 않은 상품입니다');
  }
  if (!item.name || item.name.trim() === '') {
    throw new Error('상품명은 필수입니다');
  }
  if (typeof item.price !== 'number' || item.price <= 0) {
    throw new Error('가격은 0보다 큰 숫자여야 합니다');
  }
  if (!item.id) {
    throw new Error('상품 ID는 필수입니다');
  }
  return true;
}

function addItem(items, item) {
  validateItem(item);
  return [...items, { ...item }]; // 불변성 유지
}

function ShoppingCart() {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  const handleAddItem = (item) => {
    try {
      // addItem 함수는 일관성 검사를 포함하는 순수 함수
      // 복사본을 반환함으로써 불변성 유지
      const newItems = addItem(items, item);
      setItems(newItems);
      // 총합 계산도 함수로 분리
      const newTotal = newItems.reduce((sum, item) => sum + item.price, 0);
      setTotal(newTotal);
    } catch (error) {
      alert(error.message);
    }
  };

  return (
    <div>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name} - {item.price}원
          </li>
        ))}
      </ul>
      <div>총 금액: {total}원</div>
    </div>
  );
}
```

## 3. 의존성을 적절하게 관리하라

### 의존성을 주입하라 (의존성 주입을 사용하라)

> 의존성을 구성 요소에 주입하면 유연성과 테스트 가능성이 증가한다. 의존성을 주입할 수 있게 하면 구성 요소가 더 모듈화되고 독립적으로 쉽게 테스트할 수 있다. [P.111]

실행 시점에 클래스에 서로 다른 구체적인 구현을 전달할 수 있으면 디자인의 유연성이 높아진다. [P.111]

```tsx title="잘못된 예시 - 하드코딩된 의존성"
// ❌ 잘못된 예시 - 직접 의존성을 생성
class UserService {
  private httpClient: HttpClient;
  private logger: Logger;

  constructor() {
    // 하드코딩된 의존성 - 테스트하기 어렵고 유연성이 떨어짐
    this.httpClient = new HttpClient('https://api.example.com');
    this.logger = new ConsoleLogger();
  }

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id}`);
    return this.httpClient.get(`/users/${id}`);
  }
}

// React 컴포넌트에서 사용
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // 하드코딩된 서비스 인스턴스
    const userService = new UserService();
    userService.getUser(userId).then(setUser);
  }, [userId]);

  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

```tsx title="올바른 예시 - 의존성 주입 사용"
// ✅ 올바른 예시 - 인터페이스 정의
interface HttpClient {
  get<T>(url: string): Promise<T>;
  post<T, D = unknown>(url: string, data: D): Promise<T>;
}

interface Logger {
  log(message: string): void;
  error(message: string): void;
}

interface User {
  id: string;
  name: string;
  email: string;
}

// 구체적인 구현들
class FetchHttpClient implements HttpClient {
  constructor(private baseUrl: string) {}

  async get<T>(url: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${url}`);
    return response.json();
  }

  async post<T, D = unknown>(url: string, data: D): Promise<T> {
    const response = await fetch(`${this.baseUrl}${url}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return response.json();
  }
}

class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }

  error(message: string): void {
    console.error(`[ERROR] ${message}`);
  }
}

class SilentLogger implements Logger {
  log(message: string): void {}
  error(message: string): void {}
}

// 의존성 주입을 받는 서비스
class UserService {
  constructor(
    private httpClient: HttpClient,
    private logger: Logger,
  ) {}

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id}`);
    try {
      return await this.httpClient.get<User>(`/users/${id}`);
    } catch (error) {
      this.logger.error(`Failed to fetch user ${id}: ${error}`);
      throw error;
    }
  }

  async createUser(userData: Omit<User, 'id'>): Promise<User> {
    this.logger.log(`Creating user ${userData.name}`);
    return this.httpClient.post<User>('/users', userData);
  }
}

// React Context를 사용한 의존성 주입 컨테이너
interface ServiceContainer {
  userService: UserService;
  httpClient: HttpClient;
  logger: Logger;
}

const ServiceContext = React.createContext<ServiceContainer | null>(null);

// 의존성 주입 Provider
function ServiceProvider({ children }: { children: React.ReactNode }) {
  const services = useMemo(() => {
    const httpClient = new FetchHttpClient('https://api.example.com');
    const logger = process.env.NODE_ENV === 'production' ? new SilentLogger() : new ConsoleLogger();

    return {
      httpClient,
      logger,
      userService: new UserService(httpClient, logger),
    };
  }, []);

  return <ServiceContext.Provider value={services}>{children}</ServiceContext.Provider>;
}

// 서비스를 사용하는 커스텀 훅
function useServices(): ServiceContainer {
  const services = useContext(ServiceContext);
  if (!services) {
    throw new Error('useServices must be used within a ServiceProvider');
  }
  return services;
}

// React 컴포넌트에서 사용
function UserProfile({ userId }: { userId: string }) {
  const { userService } = useServices();
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    userService
      .getUser(userId)
      .then(setUser)
      .finally(() => setLoading(false));
  }, [userId, userService]);

  if (loading) return <div>Loading...</div>;
  return user ? (
    <div>
      {user.name} - {user.email}
    </div>
  ) : (
    <div>User not found</div>
  );
}

// 테스트용 Mock 구현
class MockHttpClient implements HttpClient {
  private mockData: Record<string, any> = {};

  setMockData(url: string, data: any) {
    this.mockData[url] = data;
  }

  async get<T>(url: string): Promise<T> {
    const data = this.mockData[url];
    if (!data) throw new Error(`No mock data for ${url}`);
    return Promise.resolve(data);
  }

  async post<T>(url: string, data: any): Promise<T> {
    return Promise.resolve(data as T);
  }
}

class TestLogger implements Logger {
  public logs: string[] = [];
  public errors: string[] = [];

  log(message: string): void {
    this.logs.push(message);
  }

  error(message: string): void {
    this.errors.push(message);
  }
}

// 테스트 예시
describe('UserService', () => {
  test('should fetch user successfully', async () => {
    const mockHttpClient = new MockHttpClient();
    const testLogger = new TestLogger();
    const userService = new UserService(mockHttpClient, testLogger);

    const mockUser: User = { id: '1', name: 'John Doe', email: 'john@example.com' };
    mockHttpClient.setMockData('/users/1', mockUser);

    const user = await userService.getUser('1');

    expect(user).toEqual(mockUser);
    expect(testLogger.logs).toContain('Fetching user 1');
  });
});
```

```tsx title="함수형 프로그래밍 스타일의 의존성 주입"
// ✅ 함수형 프로그래밍 스타일 의존성 주입
type HttpClient = {
  get: <T>(url: string) => Promise<T>;
  post: <T>(url: string, data: any) => Promise<T>;
};

type Logger = {
  log: (message: string) => void;
  error: (message: string) => void;
};

type Dependencies = {
  httpClient: HttpClient;
  logger: Logger;
};

// 의존성을 받는 함수들
const createUserOperations = (deps: Dependencies) => ({
  async getUser(id: string): Promise<User> {
    deps.logger.log(`Fetching user ${id}`);
    try {
      return await deps.httpClient.get<User>(`/users/${id}`);
    } catch (error) {
      deps.logger.error(`Failed to fetch user ${id}: ${error}`);
      throw error;
    }
  },

  async createUser(userData: Omit<User, 'id'>): Promise<User> {
    deps.logger.log(`Creating user ${userData.name}`);
    return deps.httpClient.post<User>('/users', userData);
  },
});

// React 컴포넌트에서 사용
function UserProfile({ userId }: { userId: string }) {
  const { httpClient, logger } = useServices();
  const userOps = useMemo(() => createUserOperations({ httpClient, logger }), [httpClient, logger]);

  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    userOps.getUser(userId).then(setUser);
  }, [userId, userOps]);

  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

## 4. 추상화를 이해하고 잘 디자인하라

### 이쯤 되면 추상화를 고려해야 한다.

> - 같은 클래스를 계속 반복적으로 수정하고 있는가?
> - 클래스가 계속 커지고 있는가?
> - 변화를 구현하기 위해 if 문을 계속 사용하는가?
> - 기존 비지니스 규칙을 시스템의 다른 부분에 결합시키는 과정이 어거지로 이어붙이는 것 같은가?
>
> [P.136]

리액트 컴포넌트에서 반복적으로 사용되며 하나의 컴포넌트가 비대해지는 사례를 많이 만나볼 수 있다.
이 경우 추상화를 통해서 컴포넌트를 분리하거나 비지니스 로직을 커스텀 훅으로 분리하는 방법을 사용할 수 있다.
혹은 BaseComponent를 만들어 공통된 로직을 처리하고, HOC(고차 컴포넌트)를 활용하여 추상화 할 수도 있다.

---

```tsx title="잘못된 예시 - if문을 통한 반복적인 분기 처리"
// ❌ 잘못된 예시 - 여러 컴포넌트에서 반복되는 권한 체크와 로딩 로직
function UserProfile({ userId, userRole }: { userId: string; userRole: string }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // 권한 체크
    if (userRole !== 'admin' && userRole !== 'user') {
      setError('권한이 없습니다');
      setLoading(false);
      return;
    }

    // 로딩 상태 처리
    setLoading(true);
    fetchUser(userId)
      .then(setUser)
      .catch(() => setError('사용자를 불러올 수 없습니다'))
      .finally(() => setLoading(false));
  }, [userId, userRole]);

  // 반복되는 조건부 렌더링
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div className="error">{error}</div>;
  if (!user) return <div>사용자를 찾을 수 없습니다</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

function ProjectList({ userRole }: { userRole: string }) {
  const [projects, setProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // 동일한 권한 체크 로직 반복
    if (userRole !== 'admin' && userRole !== 'user') {
      setError('권한이 없습니다');
      setLoading(false);
      return;
    }

    // 동일한 로딩 상태 처리 반복
    setLoading(true);
    fetchProjects()
      .then(setProjects)
      .catch(() => setError('프로젝트를 불러올 수 없습니다'))
      .finally(() => setLoading(false));
  }, [userRole]);

  // 동일한 조건부 렌더링 반복
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div className="error">{error}</div>;
  if (!projects.length) return <div>프로젝트가 없습니다</div>;

  return (
    <div>
      {projects.map((project) => (
        <div key={project.id}>{project.name}</div>
      ))}
    </div>
  );
}

function Settings({ userRole }: { userRole: string }) {
  const [settings, setSettings] = useState<Settings | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // 또 다시 반복되는 권한 체크
    if (userRole !== 'admin') {
      setError('관리자 권한이 필요합니다');
      setLoading(false);
      return;
    }

    // 또 다시 반복되는 로딩 상태 처리
    setLoading(true);
    fetchSettings()
      .then(setSettings)
      .catch(() => setError('설정을 불러올 수 없습니다'))
      .finally(() => setLoading(false));
  }, [userRole]);

  // 또 다시 반복되는 조건부 렌더링
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div className="error">{error}</div>;
  if (!settings) return <div>설정을 찾을 수 없습니다</div>;

  return (
    <div>
      <h1>시스템 설정</h1>
      {/* 설정 UI */}
    </div>
  );
}
```

```tsx title="올바른 예시 - HOC를 통한 추상화"
// ✅ 올바른 예시 - 공통 로직을 추상화한 HOC

// 1. 권한 관리를 위한 HOC
interface WithAuthorizationProps {
  userRole: string;
}

type AuthorizedRoles = 'admin' | 'user' | 'guest';

function withAuthorization<T extends WithAuthorizationProps>(
  WrappedComponent: React.ComponentType<T>,
  allowedRoles: AuthorizedRoles[],
) {
  return function AuthorizedComponent(props: T) {
    const { userRole } = props;

    if (!allowedRoles.includes(userRole as AuthorizedRoles)) {
      return <div className="error">권한이 없습니다</div>;
    }

    return <WrappedComponent {...props} />;
  };
}

// 2. 비동기 데이터 로딩을 위한 HOC
interface WithAsyncDataProps {
  loading?: boolean;
  error?: string | null;
  data?: any;
}

function withAsyncData<T, D>(
  WrappedComponent: React.ComponentType<T>,
  dataFetcher: () => Promise<D>,
  emptyMessage: string = '데이터가 없습니다',
) {
  return function AsyncDataComponent(props: Omit<T, keyof WithAsyncDataProps>) {
    const [data, setData] = useState<D | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
      setLoading(true);
      setError(null);

      dataFetcher()
        .then(setData)
        .catch((err) => setError(err.message || '데이터를 불러올 수 없습니다'))
        .finally(() => setLoading(false));
    }, []);

    if (loading) return <div>로딩 중...</div>;
    if (error) return <div className="error">{error}</div>;
    if (!data) return <div>{emptyMessage}</div>;

    return <WrappedComponent {...(props as T)} data={data} loading={loading} error={error} />;
  };
}

// 3. 조합된 HOC를 사용한 컴포넌트들
interface UserProfileProps extends WithAuthorizationProps {
  userId: string;
  data?: User;
}

const BaseUserProfile: React.FC<UserProfileProps> = ({ data: user }) => {
  return (
    <div>
      <h1>{user!.name}</h1>
      <p>{user!.email}</p>
    </div>
  );
};

// HOC를 조합하여 최종 컴포넌트 생성
const UserProfile = withAuthorization(
  withAsyncData(BaseUserProfile, () => fetchUser('user-id'), '사용자를 찾을 수 없습니다'),
  ['admin', 'user'],
);

interface ProjectListProps extends WithAuthorizationProps {
  data?: Project[];
}

const BaseProjectList: React.FC<ProjectListProps> = ({ data: projects }) => {
  return (
    <div>
      {projects!.map((project) => (
        <div key={project.id}>{project.name}</div>
      ))}
    </div>
  );
};

const ProjectList = withAuthorization(withAsyncData(BaseProjectList, fetchProjects, '프로젝트가 없습니다'), [
  'admin',
  'user',
]);

interface SettingsProps extends WithAuthorizationProps {
  data?: Settings;
}

const BaseSettings: React.FC<SettingsProps> = ({ data: settings }) => {
  return (
    <div>
      <h1>시스템 설정</h1>
      {/* 설정 UI */}
    </div>
  );
};

const Settings = withAuthorization(
  withAsyncData(BaseSettings, fetchSettings, '설정을 찾을 수 없습니다'),
  ['admin'], // 관리자만 접근 가능
);
```

```tsx title="더 나은 예시 - 커스텀 훅과 함께 사용"
// ✅ 더 나은 예시 - 커스텀 훅으로 로직 분리

// 권한 체크 훅
function useAuthorization(userRole: string, allowedRoles: AuthorizedRoles[]) {
  const isAuthorized = allowedRoles.includes(userRole as AuthorizedRoles);
  return { isAuthorized };
}

// 비동기 데이터 훅
function useAsyncData<T>(dataFetcher: () => Promise<T>, deps: any[] = []) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    dataFetcher()
      .then(setData)
      .catch((err) => setError(err.message || '데이터를 불러올 수 없습니다'))
      .finally(() => setLoading(false));
  }, deps);

  return { data, loading, error };
}

// 컴포넌트에서 훅 사용
function UserProfile({ userId, userRole }: { userId: string; userRole: string }) {
  const { isAuthorized } = useAuthorization(userRole, ['admin', 'user']);
  const { data: user, loading, error } = useAsyncData(() => fetchUser(userId), [userId]);

  if (!isAuthorized) return <div className="error">권한이 없습니다</div>; // 복잡한 컴포넌트로 교체할 수 있음
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div className="error">{error}</div>;
  if (!user) return <div>사용자를 찾을 수 없습니다</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

function ProjectList({ userRole }: { userRole: string }) {
  const { isAuthorized } = useAuthorization(userRole, ['admin', 'user']);
  const { data: projects, loading, error } = useAsyncData(fetchProjects);

  if (!isAuthorized) return <div className="error">권한이 없습니다</div>;
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div className="error">{error}</div>;
  if (!projects?.length) return <div>프로젝트가 없습니다</div>;

  return (
    <div>
      {projects.map((project) => (
        <div key={project.id}>{project.name}</div>
      ))}
    </div>
  );
}
```

```tsx title="고급 예시 - 제네릭과 타입 안전성을 활용한 HOC"
// ✅ 고급 예시 - 타입 안전한 HOC 패턴

// 권한 체크와 데이터 로딩을 결합한 고급 HOC
interface ProtectedAsyncComponentProps<T> {
  userRole: string;
  data?: T;
  loading?: boolean;
  error?: string | null;
}

function withProtectedAsyncData<T, P extends ProtectedAsyncComponentProps<T>>(
  WrappedComponent: React.ComponentType<P>,
  options: {
    dataFetcher: (props: Omit<P, keyof ProtectedAsyncComponentProps<T>>) => Promise<T>;
    allowedRoles: AuthorizedRoles[];
    emptyMessage?: string;
    errorMessage?: string;
  },
) {
  return function ProtectedAsyncComponent(
    props: Omit<P, keyof ProtectedAsyncComponentProps<T>> & { userRole: string },
  ) {
    const { userRole, ...restProps } = props;
    const [data, setData] = useState<T | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // 권한 체크
    const isAuthorized = options.allowedRoles.includes(userRole as AuthorizedRoles);

    useEffect(() => {
      if (!isAuthorized) {
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      options
        .dataFetcher(restProps as any)
        .then(setData)
        .catch((err) => setError(options.errorMessage || err.message || '데이터를 불러올 수 없습니다'))
        .finally(() => setLoading(false));
    }, [isAuthorized, JSON.stringify(restProps)]);

    if (!isAuthorized) {
      return <div className="error">권한이 없습니다</div>;
    }

    if (loading) return <div>로딩 중...</div>;
    if (error) return <div className="error">{error}</div>;
    if (!data) return <div>{options.emptyMessage || '데이터가 없습니다'}</div>;

    return <WrappedComponent {...(props as P)} data={data} loading={loading} error={error} />;
  };
}

// 사용 예시
interface UserProfileComponentProps extends ProtectedAsyncComponentProps<User> {
  userId: string;
}

const UserProfileComponent: React.FC<UserProfileComponentProps> = ({ data: user }) => (
  <div>
    <h1>{user!.name}</h1>
    <p>{user!.email}</p>
  </div>
);

const UserProfile = withProtectedAsyncData(UserProfileComponent, {
  dataFetcher: ({ userId }: { userId: string }) => fetchUser(userId),
  allowedRoles: ['admin', 'user'],
  emptyMessage: '사용자를 찾을 수 없습니다',
  errorMessage: '사용자 정보를 불러오는데 실패했습니다',
});
```

---
