---
slug: zustand
title: zustand 라이브러리 분석
date: 2025-11-04
authors: [99mini]
tags: [typescript]
---

# zustand 라이브러리 분석

## 들어가며

Zustand의 내부를 이해하고 싶을 때 가장 먼저 살펴봐야 하는 파일이 바로 `src/vanilla.ts`와 `src/react.ts`다.
하나는 순수 자바스크립트 환경에서 동작하는 스토어 코어를, 다른 하나는 그 코어를 React 세계에 안전하게 들여오기 위한 얇은 어댑터를 제공한다.

<!-- truncate -->

---

## 1. 바닐라 스토어(`src/vanilla.ts`)의 구조

### 1-1. `createStore` - 클로저 하나로 완성되는 상태 컨테이너

`createStore`는 Zustand 사용자 경험의 출발점이다. 함수 시그니처는 오버로딩되어 있지만 현실적으로는 항상 `createState(set, get, api)` 형태의 초기화 함수를 받고 즉시 내부 구현(`createStoreImpl`)을 실행한다.

```ts
let state: TState;
const listeners = new Set<StateListener<TState>>();
```

이 두 변수가 스토어의 생애주기 전반을 책임진다. `state`는 현재 스냅샷을, `listeners`는 상태 변경 알림을 받을 콜백을 추적한다. 이후 `createState` 콜백을 실행하면서 초기 상태를 계산하고, 동시에 `initialState`를 따로 저장해둔다. 이때 `set`, `get`, `api`를 인자로 넘겨 주기 때문에 초기화 과정에서 다른 상태를 참조하거나 특정 구독을 걸어두는 것도 가능하다.

### 1-2. `setState`의 분기와 `replace` 옵션

`setState(partial, replace)`는 Zustand가 느슨한 불변성 전략을 택한다는 사실을 잘 보여준다.

```ts
// https://github.com/pmndrs/zustand/blob/main/src/vanilla.ts

const setState: StoreApi<TState>['setState'] = (partial, replace) => {
  // TODO: Remove type assertion once https://github.com/microsoft/TypeScript/issues/37663 is resolved
  // https://github.com/microsoft/TypeScript/issues/37663#issuecomment-759728342
  const nextState = typeof partial === 'function' ? (partial as (state: TState) => TState)(state) : partial;
  if (!Object.is(nextState, state)) {
    const previousState = state;
    state =
      (replace ?? (typeof nextState !== 'object' || nextState === null))
        ? (nextState as TState)
        : Object.assign({}, state, nextState);
    listeners.forEach((listener) => listener(state, previousState));
  }
};
```

- `partial`이 함수이면 `partial(state)`로 다음 상태를 계산하고, 값이면 그대로 사용한다.
- `Object.is(nextState, state)`로 변경 여부를 검사해 값이 동일하면 조용히 빠져나간다.
- 실제 변경이 필요할 때는 `replace` 플래그와 `nextState`의 타입을 함께 보고 두 가지 경로로 나뉜다.
  - `replace === true`이거나 `nextState`가 객체가 아닐 때는 **통째로 교체**.
  - 그 외에는 `Object.assign({}, state, nextState)`로 **얕은 병합**.

이렇게 만들어진 `state`는 이전 값과 함께 모든 리스너에게 전달된다. 리스너는 `(state, previousState)` 형태로 알림을 받기 때문에 필요하면 두 값을 비교해 세밀한 사이드 이펙트를 수행할 수 있다.

### 1-3. 읽기/구독 API와 `destroy`

클로저로 감싼 상태는 단 세 개의 읽기와 구독 메서드로 외부에 노출된다.

- `getState()`는 현재 스냅샷을 그대로 반환한다.
- `getInitialState()`는 스토어 생성 시 계산했던 초깃값을 돌려준다. 서버 렌더링이나 리셋 로직에서 유용하다.
- `subscribe(listener)`는 리스너를 Set에 추가하고, 해제용 함수를 반환한다.

추가로 `destroy()`도 정의되어 있지만 더 이상 필수는 아니다. 내부적으로는 `listeners.clear()`만 호출하며,
v5부터는 개발 모드 경고를 띄우고 향후 제거 예정인 deprecated API로 취급된다. 결국 cleanup은 구독 시 받은 `unsubscribe()`를 호출하는 것만으로 충분하다.

---

## 2. React 어댑터(`src/react.ts`)의 연결 고리

### 2-1. `create`로 묶는 "바운드 스토어" 패턴

React 사용자에게 익숙한 `create(set => ({ ... }))` 함수는 사실 바닐라 스토어를 그대로 노출하지 않는다.
내부에서는 먼저 `createStore`로 API 객체(`api`)를 만든 다음, 그 위에 `useStore` 훅을 감싼 `useBoundStore(selector, equalityFn)` 함수를 만들어 반환한다.

```ts
const api = typeof createState === 'function' ? createStore(createState) : createState;
const useBoundStore = (selector?, equalityFn?) => useStore(api, selector, equalityFn);
return Object.assign(useBoundStore, api);
```

함수 객체에 `getState`, `setState`, `subscribe` 등을 얹어 두었기 때문에 훅처럼 호출도 하고, `useBearStore.getState()`처럼 직접 상태를 읽는 것도 가능한 하이브리드 인터페이스가 완성된다.

### 2-2. `useStore`와 `useSyncExternalStoreWithSelector`

`useStore`는 React 18에서 도입된 `useSyncExternalStoreWithSelector`를 감싼 thin wrapper다.
전달하는 다섯 개의 인수가 전부 핵심 동작을 결정짓는다.

1. `api.subscribe` -> 외부 스토어 구독. React가 넘겨주는 콜백을 Set에 추가한다.
2. `api.getState` -> 렌더 시점의 스냅샷을 읽는 함수. 구독 알림이 오면 다시 호출된다.
3. `api.getServerState || api.getInitialState` -> SSR 대비. 서버에서 채워둔 상태가 있으면 우선 사용한다.
4. `selector` -> 컴포넌트가 필요로 하는 상태 조각만 추출한다. 기본은 아이덴티티.
5. `equalityFn` -> prev값과 선택 결과가 같은지 비교한다. 미제공 시 `Object.is`가 기본이며, v4에서 직접 인자를 넘기는 패턴은 경고가 뜰 만큼 deprecated 상태다.

이렇게 구독이 걸리면 React는 외부 스토어와 동기화하면서도 선택한 조각(slice)이 바뀔 때만 리렌더링을 트리거한다. 동시에 `useDebugValue(slice)`로 DevTools에 상태를 표시하여 디버깅 편의성도 챙긴다.

### 2-3. `selector`와`equalityFn`이 만드는 렌더링 경로

Zustand를 큰 프로젝트에서 사용할 때 성능을 좌우하는 부분은 selector와 equalityFn 조합이다.

- selector를 지정하지 않으면 스토어 전체 객체를 구독하게 되어 모든 변경에 반응한다.
- selector가 프리미티브나 안정적인 참조를 반환한다면 기본 `Object.is` 비교만으로도 리렌더링을 최소화할 수 있다.
- selector가 매번 새로운 객체를 만든다면 얕은 비교 같은 커스텀 equalityFn을 제공해야 한다.
  Zustand v4에서는 equalityFn 인라인 사용이 경고 대상이므로, 앞으로는 `createWithEqualityFn` 같은 별도 헬퍼를 사용하는 흐름으로 옮겨 가고 있다.

즉, React 레이어는 바닐라 스토어가 제공하는 단순한 구독 API 위에 `useSyncExternalStore` 프로토콜을 얹어 "필요한 값만, 필요할 때" 리렌더링하도록 보장한다.

---

## 3. 내부 설계에서 얻은 인사이트

1. **클로저 기반 상태 관리**  
   별도의 클래스나 심화된 불변성 라이브러리 없이 `state`와 `listeners`만으로 캡슐화가 끝난다.
   이는 번들 크기와 학습 비용을 모두 낮춘다.

2. **React 의존성을 철저히 분리**  
   바닐라 층은 React를 전혀 모른 채 순수 API를 노출하고,
   React 층은 `useSyncExternalStoreWithSelector`로만 의존한다. 덕분에 React 외 환경에서도 같은 스토어를 재사용할 수 있다.

3. **옵션형 최적화 지점**  
   selector/equalityFn 조합은 필요할 때만 비용을 지불하게끔 설계되어 있다.
   기본값은 단순하지만, 요구사항이 복잡해질수록 선택적으로 성능을 튜닝할 수 있다.

간결한 코드로 이 정도의 유연성과 최적화를 얻는 패턴은 다른 상태 관리 라이브러리를 설계할 때도 좋은 참고가 된다.
Zustand가 "작지만 강한" 도구라는 평을 듣는 이유가 바로 여기에 있다.

## References

- [Zustand GitHub Repository](https://github.com/pmndrs/zustand)
- [React `useSyncExternalStore` Documentation](https://react.dev/reference/react/useSyncExternalStore)
- [useMutableSource → useSyncExternalStore Discussion](https://github.com/reactwg/react-18/discussions/86)
